---
title: Python Leetcode101 动态规划(下)
date: 2022-01-18 15:35:00 +0800
categories: [Leetcode, DynamicProgramming]
tags: [Algorithm]
render_with_liquid: false
---

动态规划的内容太多了，但确实其本身也很重要。

在动态规划（上）里面放了一维、二维、分割、子序列问题。

下面是背包、字符串编辑、股票交易问题。

# 背包问题

这个在Leetcode里面没有，但是是个经典的算法问题。在这里重新捋一捋数学上的东西。

## 题目

有 *N* 个物品和容量为 *W* 的背包，每个物品都有自己的体积 w 和价值 v，求：

拿哪些物品可以使得背包所装下物品的总价值最大。

- 如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题;
- 如果不限定每种物品的数量，则问题称为无界背包问题或完全背包问题。

## 0-1背包问题的解法

可以看这个[视频](https://www.youtube.com/watch?v=nLmhmB6NzcM)，讲得很好，让我回忆起了大部分上课的时候的内容。

### 第一种解法：一个暴力的表格

```python
# 可以给出一个简单的例子，一共有四种物品，价值和质量分别如下：
p = [1, 2, 5, 6] 
w = [2, 3, 4, 5]
# 背包的总容量为
W = 8
```

那么，我们可以逐行地完成这样一个表格：

| `i`  | `pi & wi` | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---- | --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | `(0, 0)`  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1    | `(1, 2)`  | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| 2    | `(2, 3)`  | 0    | 1    | 2    | 3    | 3    | 3    | 3    | 3    |
| 3    | `(5, 4)`  | 0    | 1    | 2    | 5    | 5    | 6    | 7    | 7    |
| 4    | `(6, 5)`  | 0    | 1    | 2    | 5    | 6    | 6    | 7    | 8    |

其中，

- 每一行表示当我把第`i`个物品考虑进来的时候，对于不同的背包总容量，问题的解
- 每一列能表示当题目给出不同的`W`的时候，对于不同的物品，问题的解
- 第一行`(0, 0)`是边界条件：没有物品放的时候，就算背包容量是无穷大，价值也总为0
- 这个表的填写方式是从第一行到最后一行，先逐列填写完当前行，再填下一行

如果忘记了这个问题怎么去考虑，不妨重新再填一遍这个表，心里基本就有个思路了。

#### 状态转移方程及理解

根据这个填表的过程，可以想到状态转移方程：

- 首先，很明显有「第`i`个物品」和「背包总容量`j`」两个变量，**这是个二维动态规划问题**

- 假设`dp[i][j]`表示到第`i`个物品为止，背包总容量为`j`的情况下，能达到的最大价值

- 分别对两个变量进行阐述：

  - `i`其实是对问题进行子问题的拆分
    - 举个例子，假设一共有四个物品。当我开始考虑`i = 4`的情况就是：“我已经遍历完所有前三种物品的情况下，再加进来一个新的物品，接下来会怎样？”
  - `j`也是对问题进行子问题的拆分，只不过是在另一个维度
    - 比如，同样的4个物品，背包容量为8和背包容量为7这两个问题肯定是有联系的
    - 当我考虑`j = 8`的时候，就是：“我已经遍历完`j = 7`的所有情况了，如果背包容量再扩充一个，接下来会怎样？”

- 那么最重要的状态转移方程：

  - `dp[i][j] = max{dp[i-1][j], dp[i-1][j-w[i]] + p[i]}`

  - 比如，`dp[4][8] = max{dp[3][8], dp[3][8-5] + 6} = max{5, 2+6} = 8`

### 回溯解的过程

虽然得到了上面的表，但是那个物品选择放进去，哪个没有放，还是不明确。

需要从最后一行到第一行反向回溯。

我们对`res[4][8]`和它上面一个数`res[3][8]`进行比较，只要不等，说明这个当前这一行代表的物品选了

然后，继续找到`res[3][8-temp_weigt] = res[3][8-5]`，再比较它和它上面那个数等不等，一直找到`value=0`

![截屏2023-01-18 15 16 59](https://user-images.githubusercontent.com/84035000/213108876-a140e0f5-ee9f-4633-94ca-44158c1e0689.png)

#### Code

```python
def backpack01(w, p, W):
    res = [[0]*(W+1) for i in range(len(p)+1)]
    for i in range(1, len(res)):
        # 第0行是边界条件，从第一行开始逐行计算
        temp_w, temp_p = w[i-1], p[i-1]
        for j in range(len(res[i])):
            if j - temp_w >= 0:
                res[i][j] = max(res[i-1][j], res[i-1][j-temp_w]+temp_p)
            else:
                res[i][j] = res[i-1][j] 
    # 回溯解
    chosen = [0] * len(w) # 初始化选择列表
    i, j = len(res)-1, len(res[0])-1
    while res[i][j] != 0:
        if res[i][j] == res[i-1][j]:
            i -= 1
        else:
            chosen[i-1] = 1
            i, j = i-1, j-w[i-1]
    return res[-1][-1], chosen   # (8, [0, 1, 0, 1])
```

#### 在Jupyter Notebook上的效果

![img](https://user-images.githubusercontent.com/84035000/213101547-23b494a7-c213-4c73-aa2d-373c4f4d3dae.png)





# 416. [Partition Equal Subset Sum (Medium)](https://leetcode.cn/problems/partition-equal-subset-sum/)  

## 题目

给定一个非空数组`nums`，其中只有正整数，判断是否可以将其划分为两个子集，且两个子集的元素相等。

## Example

```python
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

## 思路

 和0/1背包问题的动态规划解法非常相似。

### 怎么去联系0/1背包问题

比较难想到的地方有两点，

- 一是要拽出来第二个维度
- 二是怎么拽出来这第二个维度

怎么能想到这两点：

- 首先，这个问题的解空间大小是`2^n`，因为每个数字我都可以选或者不选。根据这个，能联想到0/1背包问题，如果要一个一个遍历的话，也需要`2^n`次操作。想到0/1背包问题之后，就想0/1背包问题是怎么解决的
  - 它把物体的个数作为第一个维度，把背包的大小`W`作为第二个维度进行了二维动态规划
  - 那么，这个问题，是不是可以采用相似的解法。再拽出来第二个维度。
- 那，怎么拽？
  - 0/1背包问题的第二个维度是背包的大小，超出这个范围，我就不考虑了。
  - 在本问题中，我希望「选出来的数字之和」等于「所有数字总和」的一般，超出这个，我也不考虑了。
  - 这样，就可以设置「当前选出来的数字和」作为第二个维度。

### 列表找规律

就以上面Example中的`[1, 5, 11, 5]`为例，我可以列出来下面这个表，

其中，打钩的地方表示当前list中有的元素可以加和到这个数，其余地方不可以。

| 当前数字 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 無`(0)`  | √    |      |      |      |      |      |      |      |      |      |      |      |
| 1        | √    | √    |      |      |      |      |      |      |      |      |      |      |
| 5        | √    | √    |      |      |      | √    | √    |      |      |      |      |      |
| 11       | √    | √    |      |      |      | √    | √    |      |      |      |      | √    |
| 1        | √    | √    | √    |      |      | √    | √    | √    |      |      |      | √    |

规律：

- 如果`(i-1, j)`被打钩了，`(i, j)`一定也是一个钩钩
- 如果`(i-1, j-temp)`被打钩了，`(i, j)`也能是一个钩钩

根据这个规律，已经可以coding了，如果表的最后一行最后一列是钩钩，那就可以返回`True`。

## 题解

一次过的，太爽惹

```python
"""用时1456ms，超出72.50%用户；内存28.6MB，超出41.96%用户"""
class Solution(object):
    def canPartition(self, nums):
        total =  sum(nums)
        if total % 2 != 0:
            # 如果list加和为奇数，肯定没法对半拆
            return False
        # 创建一个存储解的二维表，共[len(nums)+1]行，(total/2+1)列
        res = [[0]*(total/2+1) for i in range(len(nums)+1)]
        res[0][0] = 1 # 边界条件，0个数加和为0，是可以实现的
        for i in range(1, len(res)):
            temp_num = nums[i-1]
            # print('i:', i, 'temp:',temp_num)
            for j in range(len(res[0])):
                if 0 <= j-temp_num <= len(res[0]):
                    res[i][j] = res[i-1][j] or res[i-1][j-temp_num]
                else:
                    res[i][j] = res[i-1][j]
            if res[i][-1] == 1:
                # 如果某一行的最后一列出现了True，已经可以返回True，提前终止了
                return True
        return False      
```



# 474. [ 一和零 (Medium)](https://leetcode.cn/problems/ones-and-zeroes/)

## 题目

- 有一个列表`strs`，其中存了一些由0和1组成的字符串
- 求`strs`**最多包含**`m`个0和`n`个1的最大的子集长度

## Example

```python
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

## 思路

依旧是从一个list当中，选一些出来，满足一些条件，求xxx的最值的问题，解空间依旧是`2^n`

还是可以用0/1背包问题的老套路来做，但是这次二维表格要变成三维，因为有m和n两个条件。

比如说，当只考虑"10"的时候（1个0， 1个1）

| n\m  | 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1    | 0    | 1    | 1    | 1    | 1    | 1    |
| 2    | 0    | 1    | 1    | 1    | 1    | 1    |
| 3    | 0    | 1    | 1    | 1    | 1    | 1    |

继续考虑"0001"（3个0， 1个1）

| n\m  | 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1    | 0    | 1    | 1    | 1    | 1    | 1    |
| 2    | 0    | 1    | 1    | 1    | 2    | 2    |
| 3    | 0    | 1    | 1    | 1    | 2    | 2    |

再继续考虑"111001"（2个0, 4个1），表格没有变化

| n\m  | 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1    | 0    | 1    | 1    | 1    | 1    | 1    |
| 2    | 1    | 1    | 1    | 1    | 2    | 2    |
| 3    | 1    | 1    | 1    | 1    | 2    | 2    |

- 这里我们可以发现，一个max关系隐藏在里面
- 也就是说，如果这个二维表和上一个表比较起来，考虑进新str之后，数字至少不会比上一个表的数字小

再继续考虑"1"

| n\m  | 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| 2    | 2    | 2    | 2    | 2    | 3    | 3    |
| 3    | 2    | 2    | 2    | 2    | 3    | 3    |

……

到这里规律基本上就明显了

`dp[i][j][k] = max{dp[i-1][j-temp_0][k-temp1]+1, dp[i-1][j][k]}`

## 题解

```python
class Solution(object):
    def findMaxForm(self, strs, m, n):
        def count_0_1(str):
            zero, one = 0, 0
            for char in str:
                if char == '0':
                    zero += 1
                else:
                    one += 1
            return zero, one
        # 先开辟一个存储状态的空间[(len(strs)+1) x (m+1) x (n+1)] -> [6, 6, 4]
        res = [[[0]*(n+1) for i in range(m+1)] for j in range(len(strs)+1)]
        max_i, max_j, max_k = len(res), len(res[0]), len(res[0][0])
        #print(max_i, max_j, max_k)
        for i in range(1, max_i):
            temp_0, temp_1 = count_0_1(strs[i-1])
            #print('temp0', temp_0, 'temp1', temp_1)
            for j in range(max_j):
                # j 记录 0 的数量，如果0的数量满足要求，再继续往下看 1 
                if 0 <= j - temp_0 <= max_j:
                    for k in range(max_k):
                        # k 记录 1 的数量, 如果1的数量也满足要求，可以+1
                        if 0 <= k - temp_1 <= max_k:
                            res[i][j][k] = max(res[i-1][j][k] , res[i-1][j-temp_0][k-temp_1]+1)
                        else:
                            res[i][j][k] = res[i-1][j][k] # 直接抄表
                else:
                    # 0 的数量如果已经超了，看1也没意义了，直接抄[i-1]的表
                    for k in range(max_k):
                        res[i][j][k] = res[i-1][j][k]      
            #print(res[i])  
        return res[-1][-1][-1]
```

